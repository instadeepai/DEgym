{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DEgym Documentation","text":"<p>Welcome to the DEgym framework documentation! DEgym is a comprehensive framework for creating environments for reinforcement learning which is focused on systems governed by ODEs/DAEs</p>"},{"location":"#quick-navigation","title":"Quick Navigation","text":"<ul> <li>Installation - Get started with installing DEgym.</li> <li>DEgym Essentials - Core design principles and usage patterns.</li> <li>Terminology - Key concepts and definitions.</li> <li>Tutorial - Complete guide to building new environments.</li> </ul>"},{"location":"#what-is-degym","title":"What is DEgym?","text":"<p>DEgym separates environment logic into two categories:</p> <ul> <li>RL-related logic: Core functionality shared by all environments including data handling and system interfaces.</li> <li>Use-case-related logic: Concrete implementations of abstract classes that define reactor-specific actions, states, dynamics, etc.</li> </ul> <p>The framework provides the RL-related infrastructure, while users implement only the use-case-specific components by inheriting from abstract classes.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Start with the Installation Guide.</li> <li>Read DEgym Essentials to understand the core concepts.</li> <li>Review the Terminology to familiarize yourself with key terms.</li> <li>Follow the Comprehensive Tutorial to build your first environment.</li> </ol>"},{"location":"degym_essentials/","title":"Inside DEgym: Core Design and Usage","text":""},{"location":"degym_essentials/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Inside DEgym: Core Design and Usage</li> <li>Table of Contents</li> <li>Overview</li> <li>Understanding the DEgym Architecture</li> <li>How to use DEgym</li> </ul>"},{"location":"degym_essentials/#overview","title":"Overview","text":"<p>DEgym is a framework for developing RL environment for systems governed by dynamical systems. It provides a structured approach to implementing environments that model complex systems using Differential-Algebraic Equations (DAEs) or Ordinary Differential Equations (ODEs). Additionally it offers:</p> <ul> <li>a unified structure across different use cases while remaining flexible, modular, extensible, and maintainable; and</li> <li>a rich context and output format for AI agents to complete the implementation. This is aligned with the new generation of softwares, known as Software 3.0, which are designed to be developed by AI-agents.</li> </ul>"},{"location":"degym_essentials/#understanding-the-degym-architecture","title":"Understanding the DEgym Architecture","text":"<p>To achieve the above goals, it is essential that DEgym is built with the understanding that every RL environment has components/logic that are either: (i) RL-specific, or (ii) use-case-specific which are explained below.</p> <p>[!TIP] For a refresher on basics of a RL environment, refer to Gymnasium's Basic Usage and Env API.</p> <ul> <li>RL-related logic refers to the shared structure across use cases, implemented once to define the data flow and interfaces between components. For instance, every RL environment includes a step function that takes an action, preprocesses it, passes it to an integrator to update the environment state, and then returns the next observation, reward, done flags, and info. This data flow constitutes the RL-related logic and is independent of domain-specific details. Elements like action are instances of abstract classes that must be concretely defined per use case.</li> <li>Use-case-related logic, for example what the <code>action</code> actually entails, is implemented by inheriting from the abstract classes mentioned above.</li> </ul> <p>In DEgym, we implemented all RL-related logic, leaving only the use-case-specific logic for the user or AI agent to define. The fixed data flow, well-defined interfaces, and documentation provide the agent with rich context and clear output formats, guiding the development of concrete methods. Without these guides, maintaining a unified structure across use cases --and enabling agent success-- would be much harder.</p> <p>The main RL-related logics belong to <code>__init__</code> and <code>step</code> functions. In the figure below, we have the implemented information flow in those two functions. The concrete implementation of the data types, e.g. <code>State</code>, and the abstract methods of the components like <code>RewardExtractor</code> requires knowledge the use-case.</p> <p> </p> <p>[!NOTE] For easier visualization, the above diagrams does not show the data classes which are passed between the components, nor it indicates where the information is saved.</p>"},{"location":"degym_essentials/#how-to-use-degym","title":"How to use DEgym","text":"<p>To create a new environment using DEgym, one needs to subclass the <code>Environment</code> class and implement all the required abstract classes. The <code>Environment.__init__()</code> method requires the following components:</p> <pre><code>def __init__(\n    self,\n    physical_parameters_generator: PhysicalParametersGenerator,\n    initial_state_generator: InitialStateGenerator,\n    integrator: Integrator,\n    action_preprocessor: ActionPreprocessor,\n    state_preprocessor: StatePreprocessor,\n    state_postprocessor: StatePostprocessor,\n    observation_extractor: ObservationExtractor,\n    reward_extractor: RewardExtractor,\n    terminated_extractor: TerminatedExtractor,\n    truncated_extractor: TruncatedExtractor,\n    info_extractor: InfoExtractor,\n    seed: int,\n) -&gt; None:\n</code></pre> <p>All of the above components (except the <code>Integrator</code> which is already implemented) are use-case dependent and need to be implemented by subclassing them.</p> <p>For a detailed tutorial of such implementation for a continous stirred tank reactor (CSTR) refer to Creating New Environments with DEgym: A Comprehensive Tutorial. [!TIP] For a detailed tutorial of such implementation for a continous stirred tank reactor (CSTR) refer to A Comprehensive Tutorial.</p>"},{"location":"how_to_build_new_env/","title":"Creating New Environments with DEgym: A Comprehensive Tutorial","text":"<p>This tutorial demonstrates how to create custom environments by subclassing from the DEgym framework's base <code>Environment</code> class. We'll use a Continuous Stirred-Tank Reactor (CSTR) example as a practical demonstration of the complete process.</p>"},{"location":"how_to_build_new_env/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Creating New Environments with DEgym: A Comprehensive Tutorial</li> <li>Table of Contents</li> <li>Overview</li> <li>DEgym Architecture Summary</li> <li>Building a New Environment: Complete Implementation Guide<ul> <li>Implementation Order Recommendation</li> <li>List of classes with abstract methods</li> </ul> </li> <li>Continuous Stirred-Tank Reactor<ul> <li>Goal and Constraints</li> </ul> </li> <li>Step-by-Step Implementation<ul> <li>Step 1: Identify the DAE Formulation</li> <li>Step 1.1: Identifying <code>dae_state</code></li> <li>Step 1.2: Identifying <code>dae_action</code></li> <li>Step 1.3: Identifying <code>dae_params</code></li> <li>Step 2: Define the State</li> <li>2.1. dae_state: <code>DAEState</code></li> <li>2.2. dae_params: <code>DAEParameters</code></li> <li>2.3. non_dae_params: <code>NonDAEParameters</code></li> <li>Step 2.4: State Preprocessor</li> <li>Step 3: Defining Actions</li> <li>Step 3.1: Defining <code>DAEAction</code></li> <li>Step 3.2: Defining <code>Action</code></li> <li>Step 3.3: Defining The Converter Between Action and DAEAction</li> <li>Step 3.4: Define Action Regulator</li> <li>Step 3.5: Define Action Preprocessor</li> <li>Step 4: Define the Physical Parameters</li> <li>Step 5: Define the Dynamics Function</li> <li>Step 5.1a: Defining Dynamical Equations for Scipy Integrator</li> <li>Step 5.1b: Defining Dynamical Equations for DiffEqPy Integrator</li> <li>Step 6: Defining Generators for PhysicalParameters and Initial State</li> <li>Step 6.1: Defining PhysicalParameters Generator</li> <li>Step 6.2: Defining Initial State Generator</li> <li>Step 7: Defining Extractors</li> <li>Step 7.1: Observation Extractor</li> <li>Steps 7.2-7.5: Defining Extractors for Reward, Terminated, Truncated, and Info</li> <li>Step 8: Create Your Environment Class</li> <li>Step 8.1: Calculation of time span</li> <li>Step 8.2: Computing Next DAEParameters and NonDAEParameters</li> <li>Step 9: Create Environment Factory</li> </ul> </li> <li>Conclusion</li> </ul>"},{"location":"how_to_build_new_env/#overview","title":"Overview","text":"<p>This tutorial demonstrates how to create custom environments using the DEgym framework, with a Continuous Stirred-Tank Reactor (CSTR) as a practical example.</p> <p>[!TIP] For a comprehensive overview of DEgym's core design principles, architecture, and philosophy, see Inside DEgym: Core Design and Usage.</p>"},{"location":"how_to_build_new_env/#degym-architecture-summary","title":"DEgym Architecture Summary","text":"<p>DEgym separates environment logic into two categories:</p> <ul> <li>RL-related logic: Common across all use cases (data flow, interfaces, <code>step</code> function structure).</li> <li>Use-case-related logic: Specific implementations (what actions mean, how states are defined, etc.).</li> </ul> <p>The framework provides the RL-related infrastructure, while users implement only the use-case-specific components by inheriting from abstract classes. This approach enables both human developers and AI agents to create new environments systematically.</p> <p> </p> <p>[!NOTE] For easier visualization, the above diagrams does not show the data classes which are passed between the components, nor it indicates where the information is saved.</p>"},{"location":"how_to_build_new_env/#building-a-new-environment-complete-implementation-guide","title":"Building a New Environment: Complete Implementation Guide","text":"<p>To create a custom environment in DEgym, you need to subclass the <code>Environment</code> class and implement all the required abstract classes. The <code>Environment.__init__()</code> method requires the following components:</p> <pre><code>def __init__(\n    self,\n    physical_parameters_generator: PhysicalParametersGenerator,\n    initial_state_generator: InitialStateGenerator,\n    integrator: Integrator,\n    action_preprocessor: ActionPreprocessor,\n    state_preprocessor: StatePreprocessor,\n    state_postprocessor: StatePostprocessor,\n    observation_extractor: ObservationExtractor,\n    reward_extractor: RewardExtractor,\n    terminated_extractor: TerminatedExtractor,\n    truncated_extractor: TruncatedExtractor,\n    info_extractor: InfoExtractor,\n    seed: int,\n) -&gt; None:\n</code></pre> <p>All of the above components (except the <code>Integrator</code> which is already implemented) are use-case dependent and need to be implemented. In the following we use walk through one such implementation for a continuous stirred tank reactor (CSTR). To achieve that we follow the following order.</p>"},{"location":"how_to_build_new_env/#implementation-order-recommendation","title":"Implementation Order Recommendation","text":"<ul> <li>Step 1: Identify the DAE Formulation - Identify <code>dae_state</code>, <code>dae_action</code>, <code>dae_params</code>.</li> <li>Step 2: Define the State Components - Implement state-related classes.</li> <li>Step 3: Define Actions - Implement action-related classes and processing.</li> <li>Step 4: Define Physical Parameters - Implement parameter classes.</li> <li>Step 5: Define the Dynamics Function - Implement system dynamics equations.</li> <li>Step 6: Define Generators - Implement parameter and initial state generators.</li> <li>Step 7: Define Extractors - Implement observation, reward, and termination extractors.</li> <li>Step 8: Create Environment Class - Implement your custom environment.</li> <li>Step 9: Create Environment Factory - Tie all components together with factory function.</li> </ul>"},{"location":"how_to_build_new_env/#list-of-classes-with-abstract-methods","title":"List of classes with abstract methods","text":"<p>By the end of this tutorial all the abstract methods listed below are implemented.</p> Abstract Class Abstract Methods Purpose Environment <code>_calculate_time_span()</code>, <code>_return_next_dae_params()</code> , <code>_return_next_non_dae_params()</code> Main environment interface DAEState <code>to_np_array()</code>, <code>from_np_array()</code> DAE state variables DAEParameters <code>to_np_array()</code>, <code>from_np_array()</code> DAE parameters NonDAEParameters <code>to_np_array()</code>, <code>from_np_array()</code> Non-DAE parameters Action (marker class) Semantic representation of raw step inputs DAEAction <code>to_np_array()</code>, <code>from_np_array()</code> Control variables in DAE system ActionConvertor <code>_dae_action_to_action()</code>, <code>_action_to_dae_action()</code> Convert between Action and DAE actions ActionRegulator <code>is_legal()</code>, <code>convert_to_legal_action()</code> Enforce action constraints ActionPreprocessor <code>action_space</code> (property), <code>preprocess_action()</code> Process actions before integration StatePreprocessor <code>preprocess_state()</code> Process state before integration StatePostprocessor <code>postprocess_state()</code> Process state after integration SystemDynamicsFn <code>__call__()</code> Implement system dynamics equations PhysicalParameters (marker class) Physical system parameters PhysicalParametersGenerator <code>generate()</code> Generate physical parameters InitialStateGenerator <code>generate()</code> Generate initial states Observation <code>to_np_array()</code> RL observation interface ObservationExtractor <code>observation_space</code> (property), <code>extract_observation()</code> Extract observations from state RewardExtractor <code>extract_reward()</code> Extract rewards from state transitions TerminatedExtractor <code>extract_terminated()</code> Determine episode termination TruncatedExtractor <code>extract_truncated()</code> Determine episode truncation InfoExtractor <code>extract_info()</code> Extract additional information"},{"location":"how_to_build_new_env/#continuous-stirred-tank-reactor","title":"Continuous Stirred-Tank Reactor","text":"<p>In this tutorial we focus on a reversible reaction between reactant $A$ and product $B$ under ideal CSTR conditions:</p> <p>$$\\text{A} \\overset{k_A}{\\underset{k_B}{\\rightleftharpoons}} \\text{B}$$</p> <p> </p> <ul> <li>Mass balance for $A$:</li> </ul> <p>$$\\frac{dc_A}{dt} = \\frac{F}{V} (c_{A,0} - c_A) - k_A c_A + k_B c_B$$ * Mass balance for $B$: $$\\frac{dc_B}{dt} = \\frac{F}{V} (-c_B) + k_A c_A - k_B c_B$$ * Energy balance equation: $$\\frac{dT}{dt} = \\frac{F \\rho C_p (T_0 - T) + \\dot{Q} - \\Delta H (k_A c_A - k_B c_B)}{\\rho C_p V}$$</p> <p>where * $c_A$, $c_B$ are the concentrations of species A and B. * $F$ is the flow rate. * $V$ is the reactor volume. * $k_A$, $k_B$ are the reaction rates: $k_A = k_{0A} e^{-\\frac{E_{aA}}{RT}}$ and $k_B = k_{0B} e^{-\\frac{E_{aB}}{RT}}$ with $k_{0\\mathrm{X}}$ and $E_{a\\mathrm{X}}$ being the pre-exponential factor and activation energy of $\\mathrm{X}$, and $R$ is the ideal gas constant. * $k_A$, $k_B$ are the reaction rates: $k_A = k_{0A} e^{-\\frac{E_{aA}}{RT}}$ and $k_B = k_{0B} e^{-\\frac{E_{aB}}{RT}}$ with $k_{0\\mathrm{X}}$ and $E_{a\\mathrm{X}}$ being the pre-exponential factor and activation energy of $\\mathrm{X}$, and $R$ is the ideal gas constant. These rates determine the ratio between $A$ and $B$ at a given temperature. * $T$ is the reactor temperature. * $\\dot{Q}$ is the heat input. * $\\rho$ is the density of the liquid. * $C_p$ is the heat capacity. * $\\Delta H$ is the heat of reaction.</p>"},{"location":"how_to_build_new_env/#goal-and-constraints","title":"Goal and Constraints","text":"<p>The goal of the optimization is to maximize the production of species B by controlling the heat input $\\dot{Q}$ to the reactor. This is subject to the following constraint: The heat input $\\dot{Q}$ must be between 0 and $\\dot{Q}_{\\text{max}}$ (a positive constant).</p>"},{"location":"how_to_build_new_env/#step-by-step-implementation","title":"Step-by-Step Implementation","text":"<p>Developing a new reactor environment involves these key steps:</p>"},{"location":"how_to_build_new_env/#step-1-identify-the-dae-formulation","title":"Step 1: Identify the DAE Formulation","text":"<p>This is the most important step. One must first identify the ODEs/DAEs that govern the dynamics of the reactor and represent them in the following form:</p> <pre><code>d/dt dae_state = f(dae_state, dae_params, dae_action)\n</code></pre> <p>Where: - <code>dae_state</code>: The variables that appear on the left-hand side of the DAE (the variables that are differentiated). - <code>dae_action</code>: The actions, which are commonly the handles for controlling the process, as they appear in the DAE formulation. - <code>dae_params</code>: The parameters/variables that are part of the calculation of <code>f</code> which are not <code>dae_state</code> or <code>dae_action</code>.</p> <p>Let's do this for the CSTR example above. We start by writing the equations (where $k_A$ and $k_B$ are expressed explicitly):</p> <p>$$\\frac{dc_A}{dt} = \\frac{F}{V} (c_{A,0} - c_A) - k_{0A} e^{-\\frac{E_{aA}}{RT}} c_A + k_B c_B$$</p> <p>$$\\frac{dc_B}{dt} = \\frac{F}{V} (-c_B) + k_{0A} e^{-\\frac{E_{aA}}{RT}} c_A - k_{0B} e^{-\\frac{E_{aB}}{RT}} c_B$$</p> <p>$$\\frac{dT}{dt} = \\frac{F \\rho C_p (T_0 - T) + \\dot{Q} - \\Delta H (k_{0A} e^{-\\frac{E_{aA}}{RT}} c_A - k_{0B} e^{-\\frac{E_{aB}}{RT}} c_B)}{\\rho C_p V}$$</p> <p>Now, the equations are ready to be used for identifying <code>dae_state</code>, <code>dae_action</code>, and <code>dae_params</code> in two steps. In each step: * based on simple rules, we identify a group of variables from the equations and assign them to one of the variables above; and * remove those identified variables from the equations.</p> <p>To make this process clearer, we depict the outcome of the different step process visually. All the variables that are identified at each step are highlighted in red (for their first appearance and in gray for further appearances), and then covered after removing them.</p>"},{"location":"how_to_build_new_env/#step-11-identifying-dae_state","title":"Step 1.1: Identifying <code>dae_state</code>","text":"<p>Rule: All the variables appearing on the left-hand side of the equations, shown in red color (and highlighted in gray when they also appear on the right-hand side). In the case of ODEs, these are all the differentiated variables.</p> <p> </p> <p>In the example used here, $c_A$, $c_B$ and $T$ form <code>dae_state</code>. To create the DAE state for CSTR (<code>CSTRDAEState</code>) we inherit from the <code>DAEState</code> class and implement the abstract methods (as shown below).</p> <p>[!TIP] This inheritance is a procedure that we follow throughout creating a new environment: we inherit from <code>degym</code> abstract classes and implement the abstract components based on the concrete use case.</p> <pre><code>class CSTRDAEState(DAEState):\n    \"\"\"\n    DAEState class for CSTR.\n\n    Attributes:\n        c_a: Concentration of species A\n        c_b: Concentration of species B\n        T: Current temperature of system\n    \"\"\"\n    c_a: float\n    c_b: float\n    T: float\n\n    def to_np_array(self) -&gt; NDArray:\n        \"\"\"Concatenate all the attributes.\"\"\"\n        return np.asarray(\n            [\n                self.c_a,\n                self.c_b,\n                self.T,\n            ]\n        )\n\n    @classmethod\n    def from_np_array(cls, np_array: NDArray) -&gt; \"DAEState\":\n        \"\"\"Return a new instance of the class from a numpy array.\"\"\"\n        return CSTRDAEState(\n            c_a=np_array[0],\n            c_b=np_array[1],\n            T=np_array[2],\n        )\n</code></pre> <p>The abstract methods of <code>DAEState</code> (i.e., <code>from_np_array</code> and <code>to_np_array</code>) are used in the flow of information, e.g., for passing an instance of <code>DAEState</code> to the integrator, it is first converted to a numpy array.</p> <p>For clarity, we remove these variables from the equations by covering them under a gray box.</p>"},{"location":"how_to_build_new_env/#step-12-identifying-dae_action","title":"Step 1.2: Identifying <code>dae_action</code>","text":"<p>Rule: All the variables related to actions/control as they appear in the DAE formulation</p> <p> </p> <pre><code>class CSTRDAEAction(DAEAction):\n    \"\"\"\n    Action as it appears in the DAE system.\n\n    Attributes:\n        q_dot: Heat being applied to the system.\n    \"\"\"\n\n    q_dot: float\n\n    def to_np_array(self) -&gt; NDArray[np.floating]:\n        \"\"\"Return the action as a numpy array.\"\"\"\n        return np.array([self.q_dot])\n\n    @classmethod\n    def from_np_array(cls, np_array: NDArray[np.floating]) -&gt; \"CSTRDAEAction\":\n        \"\"\"\n        Return a new instance of the class from a numpy array.\n\n        Args:\n            np_array: Numpy array with shape (1,).\n\n        Returns:\n            CSTRDAEAction: Instance of the class.\n\n        Raises:\n            ValueError: If the shape of the numpy array is not (1,).\n        \"\"\"\n        if np_array.shape != (1,):\n            raise ValueError(f\"Expected shape (1,) but got {np_array.shape}\")\n        return CSTRDAEAction(q_dot=np_array[0])\n</code></pre> <p>Similar to variables identified in the previous step, we remove the current variables from the equations by covering them under a gray box.</p>"},{"location":"how_to_build_new_env/#step-13-identifying-dae_params","title":"Step 1.3: Identifying <code>dae_params</code>","text":"<p>Rule: Any other remaining variables belong to parameters.</p> <p> </p> <p>If, similar to the previous steps, we cover these variables, there would be no other variables left in the equations.</p> <p> </p> <p>The concrete implementation of <code>CSTRDAEParameters</code> can be found in the corresponding file.</p> <p>[!IMPORTANT] - <code>dae_state</code> is not necessarily the same as the state of the reactor. It represents only the variables that appear on the left-hand side of the DAE. - <code>dae_params</code> are not necessarily the parameters needed to configure  the environment (those provided in YAML files), although there could be overlap. - The state of the environment is represented by the <code>State</code> class which includes <code>dae_state</code>, <code>dae_params</code>, and <code>non_dae_params</code> (as explained below).</p>"},{"location":"how_to_build_new_env/#step-2-define-the-state","title":"Step 2: Define the State","text":"<p>After identifying the DAE, you need to implement a subclass of <code>State</code>. Let's clarify what <code>State</code> is and what it is not:</p> <p>The <code>State</code> class represents the \"internal\" state of the environment. This internal state includes all the variables/parameters required to fully describe the environment at any point in time. In other words, the <code>State</code> has enough information to set the environment to any step in an episode.</p> <p>More explicitly, the <code>State</code> has three parts: - <code>dae_state: DAEState</code>: Variables that appear on the left-hand side of the DAE (See above). - <code>dae_params: DAEParameters</code>: Parameters used in DAE calculations (See above). - <code>non_dae_params: NonDAEParameters</code>: Parameters that are not part of the differential equations.</p>"},{"location":"how_to_build_new_env/#21-dae_state-daestate","title":"2.1. dae_state: <code>DAEState</code>","text":"<p>Refer to Step 1.1.</p>"},{"location":"how_to_build_new_env/#22-dae_params-daeparameters","title":"2.2. dae_params: <code>DAEParameters</code>","text":"<p>Refer to Step 1.2.</p>"},{"location":"how_to_build_new_env/#23-non_dae_params-nondaeparameters","title":"2.3. non_dae_params: <code>NonDAEParameters</code>","text":"<p>The <code>non_dae_params</code> contains all the necessary parameters for configuring the environment which are not part of the DAE. For example: - Parameters used for configuring constraints (e.g., maximum value of a variable or action). - Parameters that appear indirectly in the DAE (e.g., variables used to calculate <code>dae_params</code>).</p> <p>To identify these parameters, go through the description of the problem, collect all the parameters, and then remove the ones appearing in the DAE.</p> <p>For the case of CSTR, the maximum heating capacity and the duration of one episode are such parameters:</p> <pre><code>class CSTRNonDAEParameters(DAEParameters):\n    \"\"\"\n    Non-DAE parameters for the CSTR problem.\n\n    Attributes:\n        q_max: Maximum heat that can be applied at each timestep.\n        max_timestep: Number of minutes to run.\n        timestep: Current timestep.\n    \"\"\"\n\n    q_max: float\n    max_timestep: int  # Number of minutes to run\n    timestep: int = 0  # Current timestep\n\n    def to_np_array(self) -&gt; NDArray:\n        \"\"\"Concatenate all the attributes.\"\"\"\n        return np.asarray(\n            [\n                self.q_max,\n                self.max_timestep,\n                self.timestep,\n            ]\n        )\n\n    @classmethod\n    def from_np_array(cls, np_array: NDArray) -&gt; \"DAEParameters\":\n        \"\"\"Return a new instance of the class from a numpy array.\"\"\"\n        return CSTRNonDAEParameters(\n            q_max=np_array[0],\n            max_timestep=np_array[1],\n            timestep=np_array[2],\n        )\n</code></pre>"},{"location":"how_to_build_new_env/#step-24-state-preprocessor","title":"Step 2.4: State Preprocessor","text":"<p>Within the <code>step</code> function, as the first computation, the state and the action are preprocessed. The prefix pre- here refers to before integrating the dynamical equations.</p> <p>The preprocessing of the action is done by <code>ActionPreprocessor</code> (See \"Defining Action Preprocessor\" subsection below).</p> <p>The preprocessing of the state is an identity operation in the case of CSTR, i.e., the state is used without processing. Therefore, the implementation of the <code>CSTRStatePreprocessor</code> is simply subclassing <code>StatePreprocessor</code> and implementing its abstract method with an identity operation.</p> <pre><code>class CSTRStatePreprocessor(StatePreprocessor):  # noqa: D101\n    def preprocess_state(self, state: CSTRState) -&gt; CSTRState:\n        \"\"\"No preprocessing of the state is needed.\"\"\"\n        return state\n</code></pre>"},{"location":"how_to_build_new_env/#step-3-defining-actions","title":"Step 3: Defining Actions","text":"<p>In DEgym, we distinguish three representations in the action processing pipeline: 1. Raw step input: The actual input passed to the <code>step()</code> function (e.g., numpy arrays, scalars, dicts). 2. Action (semantic): An intermediate representation that gives semantic meaning to raw inputs. 3. DAEAction: The control variables as they appear in the differential equation formulation.</p> <p>The flow is: Raw Step Input \u2192 Action (semantic) \u2192 DAEAction (physical parameters)</p> <p>For example: - Raw input: <code>0.8</code> passed to <code>step()</code> (a float between 0 and 1). - Action: <code>CSTRAction(q_normalized=0.8)</code> (semantic meaning - normalized heat input). - DAEAction: <code>CSTRDAEAction(q=4000.0)</code> (physical heat input that appears in differential equations).</p>"},{"location":"how_to_build_new_env/#step-31-defining-daeaction","title":"Step 3.1: Defining <code>DAEAction</code>","text":"<p>To identify the DAE action, see Step 1.2.</p>"},{"location":"how_to_build_new_env/#step-32-defining-action","title":"Step 3.2: Defining <code>Action</code>","text":"<p>The <code>Action</code> class provides semantic meaning to raw step inputs. It transforms raw numerical data into structured, interpretable representations before conversion to physical control parameters. In the case of CSTR, for example, we define this action to interpret a raw scalar as normalized heat input:</p> <pre><code>@dataclass(frozen=True)\nclass CSTRAction(Action):\n    \"\"\"\n    Action class for CSTR problem.\n\n    The agent selects a continuous action in the range [0, 1],\n    which relates to heat being applied in the range [0, Q_max].\n    \"\"\"\n    q_normalized: float  # Normalized heat input [0, 1]\n</code></pre> <p>Note that the <code>Action</code> class serves as an intermediate semantic layer that makes control logic more interpretable and debuggable, while <code>DAEAction</code> contains the actual control variables used in differential equations.</p>"},{"location":"how_to_build_new_env/#step-33-defining-the-converter-between-action-and-daeaction","title":"Step 3.3: Defining The Converter Between Action and DAEAction","text":"<p>DEgym requires a converter between semantic actions and DAE control parameters. In the case of CSTR, this involves simple scaling from normalized to physical units. To write this converter, we inherit from the <code>ActionConvertor</code> class and implement the abstract methods:</p> <pre><code>class CSTRActionConvertor(ActionConvertor):\n    \"\"\"\n    Action convertor for the CSTR.\n    \"\"\"\n    def _action_to_dae_action(self, action: CSTRAction, state: CSTRState) -&gt; CSTRDAEAction:\n        \"\"\"Multiply the RL action by q_max to denormalize.\"\"\"\n        q = action.q_normalized * state.non_dae_params.q_max\n        return CSTRDAEAction(q=q)\n\n    def _dae_action_to_action(self, dae_action: CSTRDAEAction, state: CSTRState) -&gt; CSTRAction:\n        \"\"\"Divide the RL action by q_max to normalize.\"\"\"\n        q_normalized = dae_action.q / state.non_dae_params.q_max\n        return CSTRAction(q_normalized=q_normalized)\n</code></pre>"},{"location":"how_to_build_new_env/#step-34-define-action-regulator","title":"Step 3.4: Define Action Regulator","text":"<p>In case there are constraints on the actions, one can impose those constraints via <code>ActionRegulator</code>s. As these constraints are commonly expressed as business rules, in DEgym, the action regulators act on <code>DAEAction</code>. The abstract methods are <code>is_legal</code> and <code>convert_to_legal_action</code>. In this example, a valid (legal) action is a heat intensity between zero and the maximum allowed value (which is set in the config). The <code>convert_to_legal_action</code> method clips the actions to be in the valid range.</p> <pre><code>class CSTRActionRegulator(ActionRegulator):\n    \"\"\"\n    Action regulator for the CSTR problem.\n    \"\"\"\n    def is_legal(\n        self,\n        dae_action: CSTRDAEAction,\n        state: CSTRState,\n    ) -&gt; bool:\n        \"\"\"The action is legal if the heat stays within the bounds.\"\"\"\n        is_legal: bool = 0 &lt;= dae_action.q &lt;= state.non_dae_params.q_max\n        return is_legal\n\n    def convert_to_legal_action(self, dae_action: CSTRDAEAction, state: CSTRState) -&gt; CSTRDAEAction:\n        \"\"\"If illegal action outside [0, q_max] then clamp it.\"\"\"\n        if dae_action.q &lt;= 0:\n            return CSTRDAEAction(q=0.0)\n        if dae_action.q &gt;= state.non_dae_params.q_max:\n            return CSTRDAEAction(q=state.non_dae_params.q_max)\n        return dae_action\n</code></pre>"},{"location":"how_to_build_new_env/#step-35-define-action-preprocessor","title":"Step 3.5: Define Action Preprocessor","text":"<p><code>ActionPreprocessor</code> orchestrates the complete action processing pipeline that transforms raw step inputs into validated DAE control parameters. This is done by: 1. Wrapping raw input: Converting raw step input (arrays, scalars) into semantic Action objects. 2. Semantic conversion: Using <code>ActionConvertor</code> to transform Action to DAEAction. 3. Constraint enforcement: Applying <code>ActionRegulator</code> to ensure DAEAction compliance.</p> <p>The abstract methods that need to be implemented are <code>action_space</code> (property) and <code>preprocess_action</code>.</p> <pre><code>class CSTRActionPreprocessor(ActionPreprocessor):\n    \"\"\"Action preprocessor for the CSTR problem.\"\"\"\n    @property\n    def action_space(self) -&gt; gym.spaces.Box:\n        \"\"\"CSTR RL action space: normalized heat in [0, 1]\"\"\"\n        return gym.spaces.Box(low=0.0, high=1.0, shape=(1,))\n\n    def preprocess_action(self, action: float, state: CSTRState) -&gt; CSTRDAEAction:\n        \"\"\"\n        Preprocess a raw scalar action to validated DAEAction.\n\n        Args:\n            action: Raw scalar action from agent (normalized heat input).\n            state: Current state of the environment.\n\n        Returns:\n            CSTRDAEAction: Preprocessed action for integration.\n        \"\"\"\n        # Step 1: Wrap raw input into semantic Action\n        semantic_action = CSTRAction(q_normalized=action)\n\n        # Step 2: Convert to DAE parameters\n        dae_action = self.action_convertor.action_to_dae_action(semantic_action, state)\n\n        # Step 3: Apply constraints\n        if self.action_regulator.is_legal(dae_action, state):\n            return dae_action\n        else:\n            return self.action_regulator.convert_to_legal_action(dae_action, state)\n</code></pre>"},{"location":"how_to_build_new_env/#step-4-define-the-physical-parameters","title":"Step 4: Define the Physical Parameters","text":"<p>Physical parameters are all the parameters needed to calculate <code>dae_params</code> and <code>non_dae_params</code>. These are the parameters generated during the initialization of the environment (or its reset).</p> <p>[!NOTE] The set of physical parameters could have overlap with <code>dae_params</code> and <code>non_dae_params</code>, but they are not necessarily the same. For example, a categorical parameter could be the make/model of the reactor, from which volume is determined (and used in <code>dae_params</code> as $V$ appears in the dynamical equations). In the current example, this is not the case. The physical parameters are the result of the union of <code>dae_params</code> and <code>non_dae_params</code>.</p> <pre><code>@dataclass(frozen=True)\nclass CSTRPhysicalParameters(PhysicalParameters):\n    \"\"\"\n    Physical constants for the CSTR problem.\n\n    Attributes:\n        p: liquid density.\n        c_a_0: Initial concentration of A.\n        c_p: Heat capacity of the tank.\n        e_a: Activation energy of A -&gt; B.\n        e_b : Activation energy of B -&gt; A.\n        F: Flow rate in and out of the reactor.\n        dh: Heat of the reaction.\n        k_0_a: Pre-exponential factor for A -&gt; B.\n        k_0_b: Pre-exponential factor for B -&gt; A.\n        R: Ideal gas constant.\n        T_0: Initial temperature in the reactor.\n        V: Tank volume.\n        q_max: Max heat that can be applied at each timestep.\n        max_timestep: Number of minutes to run.\n    \"\"\"\n    p: float = 780  # kg/m\u00b3\n    c_a_0: float = 0.3  # kmol/m\u00b3\n    c_p: float = 3.25  # kJ/kgK\n    e_a: float = 41570  # kJ / kmol\n    e_b: float = 45727  # kJ / kmol\n    F: float = 0.0025  # m\u00b3/min\n    dh: float = 4157  # kJ / kmol\n    k_0_a: float = 50_000  # min-1\n    k_0_b: float = 100_000  # min-1\n    R: float = 8.314  # kJ / kmol \u2212K\n    T_0: float = 300  # K\n    V: float = 0.2  # m\u00b3\n    q_max: float = 5000  # kJ/min\n    max_timestep: int = 600 # mins\n\n    def to_np_array(self) -&gt; NDArray[np.floating]:\n        \"\"\"Concatenate all the attributes.\"\"\"\n        return np.asarray(list(asdict(self).values()))\n</code></pre> <p>The numerical values of the above physical parameters are derived from \"Dynamic Economic Optimization of a Continuously Stirred Tank Reactor Using Reinforcement Learning,\" by D. Machalek, et al. 2020.</p>"},{"location":"how_to_build_new_env/#step-5-define-the-dynamics-function","title":"Step 5: Define the Dynamics Function","text":"<p>The dynamics function calculates the derivative of the <code>dae_state</code> given the current state of the environment. This function is used in the integration of the DAE and should be implemented as a subclass of <code>DiffeqpySystemDynamicsFn</code> or <code>ScipySystemDynamicsFn</code>.</p> <p>Note that this is the most manual step in the process and the most error-prone. One must be very careful in implementing the <code>__call__</code> function.</p> <p>For both cases, one should implement the <code>__call__</code> function, in which the dynamical equations are implemented. The signature depends on the integrator (where signature variables are explained below):</p> <p>For ScipySystemDynamicsFn:</p> <pre><code>def __call__(\n    state: NDArray[np.floating],\n    parameters: NDArray[np.floating],\n    action: NDArray[np.floating],\n    time: float,\n    ) -&gt; NDArray[np.floating]:\n</code></pre> <p>For DiffeqpySystemDynamicsFn:</p> <pre><code>def __call__(\n    derivative: list[float],\n    input_values: NDArray[np.floating],\n    parameters: NDArray[np.floating],\n    time: NDArray[np.floating],\n) -&gt; None:\n</code></pre>"},{"location":"how_to_build_new_env/#step-51a-defining-dynamical-equations-for-scipy-integrator","title":"Step 5.1a: Defining Dynamical Equations for Scipy Integrator","text":"<p>For the <code>scipy</code> integrator, the arguments to the <code>__call__</code> function are: * <code>state</code> which corresponds exactly to <code>DAEState</code>. * <code>parameters</code> which corresponds exactly to <code>DAEParameters</code>. * <code>action</code> which is exactly <code>DAEAction</code>; and * <code>time</code> which is the time as it appears in the dynamical equations (in the CSTR case there is no explicit time dependence).</p> <p>These arguments are used to return the left-hand side of the dynamical equations, i.e., <code>d DAEState / dt</code> as a numpy array.</p> <p>[!NOTE] This split of arguments is in line with the logic of how parameters are grouped together in DEgym. To showcase that, in the following implementation, these arguments are converted to their counterpart DEgym classes at the beginning of the <code>__call__</code> function.</p> <pre><code>class CSTRScipySystemDynamics(ScipySystemDynamicsFn):  # noqa: D101\n    @staticmethod\n    def __call__(\n        state: NDArray[np.floating],\n        parameters: NDArray[np.floating],\n        action: NDArray[np.floating],\n        time: float,\n    ) -&gt; NDArray[np.floating]:\n        \"\"\"\n        Implement the dynamical model of CSTR.\n\n        Differential equations:\n            (1): dc_a/dt = (F / V) * (c_a0 \u2212 c_a)\u2212 k_a c_a  + k_b * c_b\n            (2): dc_b/dt = (F / V) * (\u2212 c_b) + k_a c_a  - k_b * c_b\n            (3): dT/dt = (F * p * c_p (T_0 - T) + q - dh * V\n                            * (k_a * c_a - k_b * c_b)) / (p * c_p * V)\n\n        With:\n            k_a = k_0_a * exp(-e_a / rt)\n            k_b = k_0_b * exp(-e_b / rt)\n        \"\"\"\n        s = CSTRDAEState.from_np_array(state)  # dae state\n        pm = CSTRDAEParameters.from_np_array(parameters)  # dae parameters\n        a = CSTRDAEAction.from_np_array(action)  # dae action\n\n        k_a = reaction_rate(k_0=pm.k_0_a, e=pm.E_a_A, r=pm.R, t=s.T)\n        k_b = reaction_rate(k_0=pm.k_0_b, e=pm.E_a_B, r=pm.R, t=s.T)\n\n        # Differential equations.\n        delta_c_a = (pm.F / pm.V) * (pm.c_a_0 - s.c_a) - (k_a * s.c_a) + (k_b * s.c_b)  # d[A]/dt\n        delta_c_b = (pm.F / pm.V) * (-s.c_b) + (k_a * s.c_a) - (k_b * s.c_b)  # d[B]/dt\n        delta_T = (\n            pm.F * pm.p * pm.c_p * (pm.T_0 - s.T) + a.q - pm.dh * pm.V * (k_a * s.c_a - k_b * s.c_b)\n        ) / (pm.p * pm.c_p * pm.V)  # dT/dt\n\n        return np.array([delta_c_a, delta_c_b, delta_T])\n</code></pre>"},{"location":"how_to_build_new_env/#step-51b-defining-dynamical-equations-for-diffeqpy-integrator","title":"Step 5.1b: Defining Dynamical Equations for DiffEqPy Integrator","text":"<p>Unlike the scipy integrator, DiffEqPy requires a less straightforward signature for the <code>__call__</code> function. The arguments are: * <code>derivative</code>: a list of floats which is <code>d DAEState / dt</code>. Note that this argument is set in place, i.e., at the end of the computation of time derivatives, the obtained values are placed in this list. * <code>input_values</code> corresponds exactly to variables in <code>DAEState</code>. * <code>parameters</code> contains both variables in <code>DAEParameters</code> and <code>DAEAction</code>, where the parameters appear first and the actions appear last. * <code>time</code> is time as it explicitly appears in the dynamical equations (in the CSTR example there is no explicit time dependence).</p> <p>[!NOTE] One should be very careful about how to extract <code>DAEParameters</code> and <code>DAEAction</code> from <code>parameters</code>. For example, if the action space is changed, this split should be explicitly changed.</p> <pre><code>class CSTRDiffeqpySystemDynamics(DiffeqpySystemDynamicsFn):  # noqa: D101\n    # state has 3 values: {c_a, c_b, t}\n    # We have differential equations for all 3 values =&gt; Identity matrix\n    mass_matrix = np.eye(3, 3)\n\n    @staticmethod\n    def __call__(\n        derivative: list[float],\n        input_values: NDArray[np.floating],\n        parameters: NDArray[np.floating],\n        time: NDArray[np.floating],\n    ) -&gt; None:\n        \"\"\"\n        Implement the dynamical model of CSTR.\n\n        Differential equations:\n            (1): dc_a/dt = (F / V) * (c_a0 \u2212 c_a)\u2212 k_a c_a  + k_b * c_b\n            (2): dc_b/dt = (F / V) * (\u2212 c_b) + k_a c_a  - k_b * c_b\n            (3): dT/dt = (F * p * c_p (T_0 - T) + q - dh * V\n                            * (k_a * c_a - k_b * c_b)) / (p * c_p * V)\n\n        With:\n            k_a = k_0_a * exp(-e_a / rt)\n            k_b = k_0_b * exp(-e_b / rt)\n        \"\"\"\n        s = CSTRDAEState.from_np_array(input_values)  # dae state\n        pm = CSTRDAEParameters.from_np_array(parameters[:-1])  # dae parameters\n        a = CSTRDAEAction.from_np_array(parameters[-1:])  # dae action\n\n        k_a = reaction_rate(k_0=pm.k_0_a, e=pm.E_a_A, r=pm.R, t=s.T)\n        k_b = reaction_rate(k_0=pm.k_0_b, e=pm.E_a_B, r=pm.R, t=s.T)\n\n        # Differential equations.\n        derivative[0] = (\n            (pm.F / pm.V) * (pm.c_a_0 - s.c_a) - (k_a * s.c_a) + (k_b * s.c_b)\n        )  # d[A]/dt\n        derivative[1] = (pm.F / pm.V) * (-s.c_b) + (k_a * s.c_a) - (k_b * s.c_b)  # d[B]/dt\n        derivative[2] = (\n            pm.F * pm.p * pm.c_p * (pm.T_0 - s.T) + a.q - pm.dh * pm.V * (k_a * s.c_a - k_b * s.c_b)\n        ) / (pm.p * pm.c_p * pm.V)  # dT/dt\n\n</code></pre>"},{"location":"how_to_build_new_env/#step-6-defining-generators-for-physicalparameters-and-initial-state","title":"Step 6: Defining Generators for PhysicalParameters and Initial State","text":"<p>DEgym requires two generators for instantiation and reset: * A subclass of PhysicalParametersGenerator which generates an instance of <code>PhysicalParameters</code>. Having a generator instead of just using an instance of <code>PhysicalParameters</code> enables us to create (random) variation in parameters of the environment. For example, if a use case requires training an agent for controlling a reactor where the $\\Delta H$ is coming from a random distribution, one can realize that with the generator.</p> <ul> <li>A subclass of <code>InitialStateGenerator</code> which generates an instance of <code>State</code> as the initial state of the environment. Similar to the physical parameter generator, a generator can set the environment in different initial states every time an instance of the environment is created or reset.</li> </ul>"},{"location":"how_to_build_new_env/#step-61-defining-physicalparameters-generator","title":"Step 6.1: Defining PhysicalParameters Generator","text":"<p>For the CSTR use case, similar to any concrete reactor, we create a subclass of <code>PhysicalParametersGenerator</code> and implement its abstract method <code>generate</code> with the following signature:</p> <pre><code>class PhysicalParametersGenerator(ABC):\n    \"\"\"Generator for physical parameters of the system.\"\"\"\n\n    @abstractmethod\n    def generate(self, rng: np.random.Generator) -&gt; PhysicalParameters:\n        \"\"\"Generate a set of physical parameters describing an instantiation of the system.\"\"\"\n</code></pre> <p>[!NOTE] The logic with which the physical parameters are generated is irrelevant for DEgym. For example, in the CSTR case we implemented <code>CSTRPhysicalParametersGenerator</code> which returns an instance of <code>CSTRPhysicalParameters</code> where some of the parameters are generated randomly and some have fixed values. Whether a parameter has fixed values or it is derived from a distribution is configured by a config.</p> <p>For details of the implementation refer to <code>physical_parameters.py</code> in <code>degym_tutorial/</code>.</p>"},{"location":"how_to_build_new_env/#step-62-defining-initial-state-generator","title":"Step 6.2: Defining Initial State Generator","text":"<p>To develop an initial state generator, one can subclass <code>InitialStateGenerator</code> and implement its only abstract method which is <code>generate</code>. Note that to generate an initial state one requires knowing the physical parameters of the system. Therefore, an instance of <code>PhysicalParameters</code> (or <code>CSTRPhysicalParameters</code> in the case of the CSTR example) is passed to the <code>generate</code> function.</p> <pre><code>class CSTRInitialStateGenerator(InitialStateGenerator):\n    \"\"\"InitialStateGenerator class for the CSTR problem.\"\"\"\n\n    def generate(self, physical_parameters: CSTRPhysicalParameters) -&gt; CSTRState:\n        \"\"\"Return the initial state given a set of physical parameters for the system.\"\"\"\n        dae_state = CSTRDAEState(\n            c_a=physical_parameters.c_a_0,\n            c_b=0.0,\n            T=physical_parameters.T_0,\n        )\n\n        dae_params = CSTRDAEParameters(\n            F=physical_parameters.F,\n            V=physical_parameters.V,\n            c_a_0=physical_parameters.c_a_0,\n            p=physical_parameters.p,\n            c_p=physical_parameters.c_p,\n            T_0=physical_parameters.T_0,\n            dh=physical_parameters.dh,\n            k_0_a=physical_parameters.k_0_a,\n            k_0_b=physical_parameters.k_0_b,\n            E_a_A=physical_parameters.e_a,\n            E_a_B=physical_parameters.e_b,\n            R=physical_parameters.R,\n        )\n        non_dae_params = CSTRNonDAEParameters(\n            q_max=physical_parameters.q_max,\n            max_timestep=physical_parameters.max_timestep,\n            timestep=0,\n        )\n        return CSTRState(dae_state=dae_state, dae_params=dae_params, non_dae_params=non_dae_params)\n\n</code></pre>"},{"location":"how_to_build_new_env/#step-7-defining-extractors","title":"Step 7: Defining Extractors","text":"<p>Extractors convert the internal state to the return values of the <code>step</code> function dictated by Gymnasium's convention: (i) observation, (ii) reward, (iii) terminated, (iv) truncated, (v) info. In the following, we explain the observation extractor in detail and the other extractors are briefly described.</p> <p>[!NOTE] These extractors are called at the very end of the <code>step</code> function.</p>"},{"location":"how_to_build_new_env/#step-71-observation-extractor","title":"Step 7.1: Observation Extractor","text":"<p>The observation extractor converts the internal state to the observation that the RL agent receives. To implement this extractor: * first we need to implement a class for observation by subclassing the <code>Observation</code> class and implementing its abstract method, i.e. <code>to_np_array</code>; and then * subclass the <code>ObservationExtractor</code> class and implement its abstract method and property, i.e., <code>extract_observation</code> and <code>observation_space</code>.</p> <pre><code>@dataclass(frozen=True)\nclass CSTRObservation(Observation):\n    \"\"\"Observation returned to the RL agent for CSTR.\"\"\"\n    normalized_c_a: float  # Normalized concentration of A\n    normalized_c_b: float  # Normalized concentration of B\n    normalized_temperature: float  # Normalized temperature\n\n    def to_np_array(self) -&gt; NDArray[np.floating]:\n        \"\"\"Convert observation to numpy array.\"\"\"\n        return np.array([self.normalized_c_a, self.normalized_c_b, self.normalized_temperature])\n\nclass CSTRObservationExtractor(ObservationExtractor):\n    \"\"\"Extract observations from CSTR state.\"\"\"\n\n    @property\n    def observation_space(self) -&gt; gym.spaces.Box:\n        \"\"\"Define the observation space for RL agents.\"\"\"\n        return gym.spaces.Box(\n            low=np.array([0.0, 0.0, 0.0]),\n            high=np.array([1.0, 1.0, 2.0]),\n            shape=(3,),\n            dtype=np.float32\n        )\n\n    def extract_observation(self, next_state: CSTRState) -&gt; CSTRObservation:\n        \"\"\"Convert state to observation by normalizing values.\"\"\"\n        # Normalize concentrations by initial concentration\n        c_a_normalized = next_state.dae_state.c_a / next_state.dae_params.c_a_0\n        c_b_normalized = next_state.dae_state.c_b / next_state.dae_params.c_a_0\n\n        # Normalize temperature by initial temperature\n        t_normalized = next_state.dae_state.T / next_state.dae_params.T_0\n\n        return CSTRObservation(\n            normalized_c_a=c_a_normalized,\n            normalized_c_b=c_b_normalized,\n            normalized_temperature=t_normalized\n        )\n</code></pre> <p>[!NOTE] * The observation depends only on <code>next_state</code>. * <code>next_state</code> here refers to the state of the environment after the postprocessing (which comes after the application of action).</p>"},{"location":"how_to_build_new_env/#steps-72-75-defining-extractors-for-reward-terminated-truncated-and-info","title":"Steps 7.2-7.5: Defining Extractors for Reward, Terminated, Truncated, and Info","text":"<p>All the remaining extractors: * are simpler than the observation extractor as their return types are basic Python types, i.e., <code>float</code>, <code>bool</code>, and <code>dict</code>; and * they share the same list of arguments: <code>self, state: State, action: DAEAction, next_state: State</code>.</p> <p>In their argument list: * <code>state</code> is the <code>State</code> at the beginning of the <code>step</code> (i.e., before application of action). * <code>action</code> is the action taken in the step. * <code>next_state</code>: The state at the end of the <code>step</code> after the postprocessing (which comes after the application of action).</p> <p>As an example here we show <code>CSTRRewardExtractor</code>:</p> <pre><code>class CSTRRewardExtractor(RewardExtractor):  # noqa: D101\n    def extract_reward(\n        self, state: CSTRState, action: CSTRDAEAction, next_state: CSTRState\n    ) -&gt; float:\n        \"\"\"Immediate reward is the concentration of the product, c_B.\"\"\"\n        return float(next_state.dae_state.c_b)\n</code></pre>"},{"location":"how_to_build_new_env/#step-8-create-your-environment-class","title":"Step 8: Create Your Environment Class","text":"<p>In the <code>Environment</code> class of DEgym, there are also two abstract methods that should be implemented: * <code>_calculate_time_span</code>: where one calculates the time span covered by the <code>step</code> function. This function is called inside the step function, before the integration. It is used for setting the beginning and end of the time integration for the current call to <code>step</code>. Note that this function enables us to have variable time spans across calls to the step function, which is a relevant feature for chemical/biological reactors.</p> <ul> <li><code>_return_next_dae_params</code>: updates and returns the <code>dae_params</code>.</li> <li><code>_return_next_non_dae_params</code>: updates and returns the <code>non_dae_params</code>.</li> </ul> <p>[!NOTE] Non-DAE Parameters can change with time. For example, the cost of energy which does not appear in chemical reactions might change with time; it has its own dynamics which require an update during the step for the given time span.</p>"},{"location":"how_to_build_new_env/#step-81-calculation-of-time-span","title":"Step 8.1: Calculation of time span","text":"<p>In the CSTR environment we assume a fixed constant time span across all steps. In this case, the logic of the time span computation is straightforward:</p> <pre><code>class CSTREnvironment(Environment):\n    \"\"\"\n    Environment for the CSTR problem.\n    \"\"\"\n    def _calculate_time_span(self) -&gt; TimeSpan:\n        \"\"\"Calculate the time span of step function.\"\"\"\n        time_span = TimeSpan(\n            start_time=self._current_time,\n            end_time=self._current_time + self._integrator.config.action_duration,\n        )\n        return time_span\n</code></pre>"},{"location":"how_to_build_new_env/#step-82-computing-next-daeparameters-and-nondaeparameters","title":"Step 8.2: Computing Next DAEParameters and NonDAEParameters","text":"<p>These methods allow us to have a time dependence for <code>dae_params</code> as well as <code>non_dae_params</code>.</p> <pre><code>    def _return_next_dae_params(self, state: CSTRState) -&gt; CSTRDAEParameters:\n        \"\"\"Return the current DAE parameters as the next DAE parameters.\"\"\"\n        return state.dae_params\n\n    def _return_next_non_dae_params(self, state: CSTRState) -&gt; CSTRNonDAEParameters:\n        \"\"\"Return the next non-DAE parameters by incrementing the timestep.\"\"\"\n        state.non_dae_params.timestep += 1\n        return state.non_dae_params\n</code></pre>"},{"location":"how_to_build_new_env/#step-9-create-environment-factory","title":"Step 9: Create Environment Factory","text":"<p>We are almost done! Here is a factory function to instantiate your CSTR environment from a config!</p> <pre><code>def make_cstr_environment(env_config: dict) -&gt; CSTREnvironment:  # pylint: disable=too-many-locals\n    \"\"\"\n    Instantiate and return a CSTR environment.\n\n    Args:\n        a dict which includes all the configs of the environment.\n\n    Returns:\n        an environment.\n    \"\"\"\n    physical_parameter_generator_config = CSTRPhysicalParametersGeneratorConfig(\n        **env_config[\"physical_parameters\"]\n    )\n    physical_parameters_generator = CSTRPhysicalParametersGenerator(\n        config=physical_parameter_generator_config\n    )\n\n    # Prepare preprocessing classes\n    action_regulator = CSTRActionRegulator()\n    action_convertor = CSTRActionConvertor()\n    action_preprocessor = CSTRActionPreprocessor(\n        action_convertor=action_convertor, action_regulator=action_regulator\n    )\n    state_preprocessor = CSTRStatePreprocessor()\n\n    # Prepare integrator\n    if env_config[\"integrator\"] == \"diffeqpy\":\n        system_dynamics = CSTRDiffeqpySystemDynamics()\n        integrator_config = DiffeqpyIntegratorConfig(**env_config[\"integrator_config\"])\n        integrator = DiffeqpyIntegrator(\n            system_dynamics=system_dynamics, integrator_config=integrator_config\n        )\n    elif env_config[\"integrator\"] == \"scipy\":\n        system_dynamics = CSTRScipySystemDynamics()\n        integrator_config = ScipyIntegratorConfig(**env_config[\"integrator_config\"])\n        integrator = ScipyIntegrator(\n            system_dynamics=system_dynamics, integrator_config=integrator_config\n        )\n    else:\n        raise NotImplementedError(f\"Integrator {env_config['integrator']} not implemented\")\n\n    # Prepare extractors + state postprocessor\n    observation_extractor = CSTRObservationExtractor()\n    reward_extractor = CSTRRewardExtractor()\n    terminated_extractor = CSTRTerminatedExtractor()\n    truncated_extractor = CSTRTruncatedExtractor()\n    info_extractor = CSTRInfoExtractor()\n    state_postprocessor = CSTRStatePostprocessor()\n\n    # Instantiate CSTR Environment\n    env = CSTREnvironment(\n        physical_parameters_generator=physical_parameters_generator,\n        initial_state_generator=CSTRInitialStateGenerator(),\n        integrator=integrator,\n        action_preprocessor=action_preprocessor,\n        state_preprocessor=state_preprocessor,\n        state_postprocessor=state_postprocessor,\n        observation_extractor=observation_extractor,\n        reward_extractor=reward_extractor,\n        terminated_extractor=terminated_extractor,\n        truncated_extractor=truncated_extractor,\n        info_extractor=info_extractor,\n        seed=env_config[\"random_seed\"],\n    )\n\n    return env\n</code></pre> <p>Having this factory, we can now easily create an environment and interact with it:</p> <pre><code>import numpy as np\nfrom make_env import make_cstr_environment\n\n# For the reference of the physical parameters see:\n# D. Machalek, T. Quah and K. M. Powell,\n# \"Dynamic Economic Optimization of a Continuously Stirred Tank Reactor Using Reinforcement Learning,\"\n# 2020 American Control Conference (ACC), Denver, CO, USA, 2020, pp. 2955-2960,\n# doi: 10.23919/ACC45564.2020.9147706.\nenv_config = {\n    \"integrator\": \"scipy\",\n    \"integrator_config\": {\n        \"action_duration\": 0.1,\n        \"method\": \"RK45\",\n        \"rtol\": 1e-6,\n        \"atol\": 1e-8,\n            },\n            \"random_seed\": 0,\n            \"physical_parameters\": {\n                \"fixed_values\": {\n                    \"c_a_0\": 0.3,\n                    \"c_p\": 3.25,\n                    \"e_a\": 41570,\n                    \"e_b\": 45727,\n                    \"f\": 0.0025,\n                    \"dh\": 4157,\n                    \"k_0_a\": 50_000,\n                    \"k_0_b\": 100_000,\n                    \"r\": 8.314,\n                    \"t_0\": 300,\n                    \"v\": 0.2,\n                    \"q_max\": 5000,\n                    \"max_timestep\": 100,\n                },\n                \"sampled_values\": {\n                    \"p\": {\"distribution\": \"choice\", \"choices\": [780, 790], \"size\": 1}\n                },\n            },\n        }\n\nenv = make_cstr_environment(env_config)\nenv.reset()\ndone = False\nwhile not done:\n    action = np.random.uniform(0.0, 1.0)  # Raw scalar: normalized heat input\n    next_state, reward, terminated, truncated, info = env.step(action)\n    done = terminated or truncated\n\n</code></pre>"},{"location":"how_to_build_new_env/#conclusion","title":"Conclusion","text":"<p>This tutorial has shown you how to create custom environments using the DEgym framework, following the methodology outlined in the official documentation. The key is to understand the separation between DAE components and RL components, and to implement each piece systematically starting with the DAE formulation.</p> <p>The CSTR example demonstrates a complete, working implementation that you can use as a reference for your own environments.</p>"},{"location":"installation/","title":"Installation Guide","text":"<p>This guide provides step-by-step instructions for installing DEgym and its dependencies for different use cases.</p>"},{"location":"installation/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Package Manager Setup</li> <li>Installation Options</li> <li>Docker Installation</li> <li>Environment Setup</li> <li>Troubleshooting</li> </ol>"},{"location":"installation/#package-manager-setup","title":"Package Manager Setup","text":"<p>DEgym uses <code>uv</code> for fast and reliable package management. This is the recommended approach for all installations.</p>"},{"location":"installation/#installing-uv","title":"Installing uv","text":"<p>Follow the installation guide in the uv documentation to install <code>uv</code> on your system.</p> <p>Quick installation:</p> <pre><code># On macOS and Linux\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# On Windows\npowershell -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n</code></pre>"},{"location":"installation/#getting-the-repository","title":"Getting the Repository","text":"<p>Clone the DEgym repository:</p> <pre><code>git clone git@github.com:instadeepai/degym.git\ncd degym\n</code></pre>"},{"location":"installation/#installation-options","title":"Installation Options","text":"<p>Choose the installation option that best fits your use case:</p>"},{"location":"installation/#1-basic-installation-recommended-for-most-users","title":"1. Basic Installation (Recommended for most users)","text":"<p>This installs the core DEgym framework with SciPy-based integrators, suitable for most chemical reactor simulations.</p> <pre><code>uv sync\n</code></pre> <p>What's included: - Core DEgym framework. - SciPy integrators. - Basic RL environment functionality. - Essential dependencies for building and running reactor simulations.</p>"},{"location":"installation/#2-development-installation","title":"2. Development Installation","text":"<p>For developers contributing to DEgym or those who need testing and linting tools.</p> <pre><code>uv sync --group test\nuv pip install -e .\n</code></pre> <p>What's included: - Everything from Basic Installation. - Testing frameworks (pytest, etc.). - Code linting tools. - Development utilities.</p>"},{"location":"installation/#4-diffeqpy-installation-experimental","title":"4. DiffEqPy Installation (Experimental)","text":"<p>For advanced users who need Julia-based differential equation solvers.</p> <pre><code>uv sync --group diffeqpy\nuv run build/install_julia.py\n</code></pre> <p>What's included: - Everything from Basic Installation. - Julia-based DiffEqPy integrators. - Advanced numerical solvers.</p> <p>[!WARNING] The DiffEqPy installation requires Julia and is currently not stable for local or CI builds. Use with caution in production environments.</p>"},{"location":"installation/#dependency-groups-summary","title":"Dependency Groups Summary","text":"Group Purpose Use Case Core Basic DEgym functionality Building and running RL environments test Development tools Contributing to DEgym, testing diffeqpy Advanced solvers High-performance numerical integration"},{"location":"installation/#docker-installation","title":"Docker Installation","text":"<p>For containerized deployments, DEgym provides several Docker images optimized for different use cases.</p>"},{"location":"installation/#available-docker-images","title":"Available Docker Images","text":"<ul> <li>degym-aichor: Production image for SciPy integrators on AIChor platform.</li> <li>degym-ci: CI/CD image with testing capabilities and Git support.</li> <li>degym-diffeqpy: Experimental image with Julia-based DiffEqPy integrators.</li> </ul>"},{"location":"installation/#building-docker-images","title":"Building Docker Images","text":"<pre><code># Build the AIChor production image\ndocker build --target degym-aichor -t degym-aichor .\n\n# Build the CI/testing image\ndocker build --target degym-ci -t degym-ci .\n\n# Build the DiffEqPy image (experimental)\ndocker build --target degym-diffeqpy -t degym-diffeqpy .\n</code></pre>"},{"location":"installation/#using-docker-images","title":"Using Docker Images","text":"<pre><code># Run with the AIChor image\ndocker run -it degym-aichor\n\n# Run with volume mounting for development\ndocker run -v $(pwd):/workspace -it degym-ci bash\n</code></pre>"},{"location":"installation/#environment-setup","title":"Environment Setup","text":""},{"location":"installation/#running-commands","title":"Running Commands","text":"<p>Use <code>uv run</code> to execute commands within the virtual environment:</p> <pre><code># Run Python scripts\nuv run python path_to_script.py\n\n# Run tests\nuv run pytest\n\n# Install additional packages\nuv add package_name\n</code></pre>"},{"location":"installation/#python-path-configuration","title":"Python Path Configuration","text":"<p>If you encounter <code>ModuleNotFoundError</code> when running scripts, make sure you have installed the package in editable mode:</p> <pre><code>uv pip install -e .\n</code></pre>"},{"location":"installation/#verification","title":"Verification","text":""},{"location":"installation/#test-your-installation","title":"Test Your Installation","text":"<p>Verify your installation by running a simple test:</p> <pre><code># Run basic tests\nuv run pytest tests/\n\n# Test a simple environment\nuv run python -c \"import degym; print('DEgym imported successfully!')\"\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#common-issues","title":"Common Issues","text":"<p>1. ModuleNotFoundError</p> <pre><code># Solution: Update PYTHONPATH\nexport PYTHONPATH=$PWD:$PYTHONPATH\n</code></pre> <p>2. uv command not found</p> <pre><code># Solution: Ensure uv is in your PATH or reinstall\ncurl -LsSf https://astral.sh/uv/install.sh | sh\nsource ~/.bashrc  # or restart terminal\n</code></pre>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<p>After successful installation:</p> <ol> <li>Read Documentation: Read the DEgym Essentials to understand the framework architecture and basic usage.</li> <li>Read the Tutorial: Follow the comprehensive tutorial to create your first custom environment, and check out the CSTR examples in the <code>degym_tutorials/</code> directory.</li> <li>Start Implementing Your Env \ud83e\uddd1\u200d\ud83c\udf73\u2697\ufe0f <p>[!TIP] For the best development experience, we recommend using the Development Installation with your preferred IDE configured for Python development.</p> </li> </ol>"},{"location":"terminology/","title":"DEgym Terminology","text":"<p>This document defines key terms and concepts used throughout the DEgym framework.</p>"},{"location":"terminology/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Environment</li> <li>State Components</li> <li>Action Components</li> <li>Processing Pipeline</li> <li>Extractors</li> <li>Integration Components</li> <li>Environment Components</li> </ul>"},{"location":"terminology/#environment","title":"Environment","text":""},{"location":"terminology/#environment_1","title":"Environment","text":"<p>The main interface between RL agents and reactor simulations. Inherits from Gymnasium's <code>Env</code> class and provides the standard RL interface (<code>step()</code>, <code>reset()</code>, etc.). The Environment coordinates all other components and maintains the internal simulation state.</p> <p>Usage in DEgym: Acts as the central orchestrator that manages the complete simulation lifecycle, from initialization through episode execution.</p>"},{"location":"terminology/#episode","title":"Episode","text":"<p>A complete simulation run from initialization to termination/truncation. Each episode represents one training or evaluation trajectory for the RL agent.</p> <p>Usage in DEgym: Episodes are bounded by <code>reset()</code> and end when terminated or truncated conditions are met.</p>"},{"location":"terminology/#state-components","title":"State Components","text":""},{"location":"terminology/#state","title":"State","text":"<p>The complete internal representation of the environment at any given time. Contains all information needed to fully describe the reactor system and continue simulation from that point.</p> <p>Components: - <code>dae_state</code>: Variables that appear on the left-hand side of differential equations. - <code>dae_params</code>: Parameters used in the differential equations. - <code>non_dae_params</code>: Parameters not part of the differential equations but needed for simulation.</p> <p>Usage in DEgym: The State is passed between components throughout the simulation pipeline and gets updated at each timestep.</p>"},{"location":"terminology/#what-state-is-not","title":"What <code>State</code> is NOT!","text":"<p>State is a common term used in different disciplines where it points to somewhat different concepts. The state here is not: - The state as in a point in phase space. - The state as in DAEState (e.g., the variables that are differentiated).</p>"},{"location":"terminology/#why-do-we-organize-the-state-this-way","title":"Why do we organize the <code>State</code> this way?","text":"<p>We split the state values into these components so that we can easily retrieve and separate the state values required for implementing a reactor. This choice is motivated by the structure of the DAE and the way we implement the dynamics function.</p>"},{"location":"terminology/#daestate","title":"DAEState","text":"<p>Variables that appear on the left-hand side of differential equations (the variables being differentiated).</p> <p>Examples: Concentrations (c_A, c_B), temperature (T), pressure (P).</p> <p>Usage in DEgym: Updated by numerical integration and represents the evolving state of the system.</p>"},{"location":"terminology/#daeparameters","title":"DAEParameters","text":"<p>Parameters that appear in the differential equations but are not differentiated variables.</p> <p>Examples: Flow rates (F), reactor volume (V), kinetic constants (k_0_a, k_0_b), activation energies (E_a), etc.</p> <p>Usage in DEgym: Used by the integrator in differential equation calculations.</p>"},{"location":"terminology/#nondaeparameters","title":"NonDAEParameters","text":"<p>Parameters needed for simulation but not part of the differential equations.</p> <p>Examples: Maximum heat input (q_max), episode length (max_timestep), current timestep, constraint limits.</p> <p>Usage in DEgym: Used for simulation control, constraints, and episode management.</p>"},{"location":"terminology/#physicalparameters","title":"PhysicalParameters","text":"<p>High-level parameters that characterize a specific reactor configuration. Used to generate both DAEParameters and NonDAEParameters.</p> <p>[!NOTE] <code>PhysicalParameter</code> is not the config that is passed to <code>make_cstr_environment</code>.</p> <p>Examples: Reactor geometry, parameters of operating constraints, reaction kinetics, feed composition.</p> <p>Usage in DEgym: Generated at episode start and remain constant within an episode, but can vary between episodes for domain randomization.</p>"},{"location":"terminology/#action-components","title":"Action Components","text":""},{"location":"terminology/#raw-action","title":"Raw Action","text":"<p>The direct input passed to the environment's <code>step()</code> function by the RL agent. Can be scalars, numpy arrays, or other data types as defined by the action space.</p> <p>Usage in DEgym: Raw actions are the starting point of the action processing pipeline.</p>"},{"location":"terminology/#action","title":"Action","text":"<p>An intermediate representation that gives semantic meaning to raw actions. Provides named fields and interpretable structure before conversion to physical control parameters.</p> <p>Purpose: - Makes control logic interpretable and debuggable. - Bridges between RL agent outputs and physical system requirements. - Enables clear mapping from agent decisions to control intentions.</p> <p>Usage in DEgym: Actions are created by wrapping raw inputs and then converted to DAEActions.</p>"},{"location":"terminology/#daeaction","title":"DAEAction","text":"<p>Control parameters as they appear directly in the differential equation system. These are domain-specific, physically meaningful control inputs that affect system dynamics.</p> <p>Purpose: - Encapsulates control parameters for differential equation integration. - Ensures actions are in physically meaningful units and ranges. - Enables direct use in system dynamics calculations.</p> <p>Usage in DEgym: DAEActions are passed to the integrator for numerical solving.</p>"},{"location":"terminology/#actionconvertor","title":"ActionConvertor","text":"<p>Transforms semantic Actions into DAEActions and vice versa. Handles scaling, unit conversion, and complex control logic transformations.</p> <p>Usage in DEgym: Called during action preprocessing to bridge semantic and physical representations.</p>"},{"location":"terminology/#actionregulator","title":"ActionRegulator","text":"<p>Enforces constraints on DAEActions to ensure they remain within safe and feasible bounds.</p> <p>Methods: - <code>is_legal()</code>: Checks if an action satisfies all constraints. - <code>convert_to_legal_action()</code>: Corrects constraint-violating actions.</p> <p>Usage in DEgym: Applied after action conversion to ensure safe operation.</p>"},{"location":"terminology/#actionpreprocessor","title":"ActionPreprocessor","text":"<p>Orchestrates the complete action processing pipeline from raw inputs to validated DAEActions.</p> <p>Pipeline: 1. Wrap raw input into semantic Action. 2. Convert Action to DAEAction using ActionConvertor. 3. Apply constraints using ActionRegulator. 4. Return validated DAEAction for integration.</p> <p>Usage in DEgym: Called by the Environment during each <code>step()</code> to process agent actions.</p>"},{"location":"terminology/#processing-pipeline","title":"Processing Pipeline","text":""},{"location":"terminology/#preprocessor","title":"Preprocessor","text":"<p>Coordinates preprocessing of both state and action before numerical integration.</p> <p>Usage in DEgym: Called at the beginning of each <code>step()</code> to prepare inputs for the integrator.</p>"},{"location":"terminology/#statepreprocessor","title":"StatePreprocessor","text":"<p>Processes the state before numerical integration. Can apply transformations, corrections, or preparation steps.</p> <p>Usage in DEgym: Ensures the state is in the correct format and range for numerical solving.</p>"},{"location":"terminology/#statepostprocessor","title":"StatePostprocessor","text":"<p>Processes the state after numerical integration to handle corrections, constraints, or transformations.</p> <p>Usage in DEgym: Ensures the integrated state satisfies physical constraints and is ready for extraction.</p>"},{"location":"terminology/#extractors","title":"Extractors","text":"<p>Extractors convert internal state to the outputs required by the Gymnasium interface.</p>"},{"location":"terminology/#observationextractor","title":"ObservationExtractor","text":"<p>Converts environment state to observations that RL agents receive.</p> <p>Components: - <code>observation_space</code>: Defines the structure and bounds of observations. - <code>extract_observation()</code>: Transforms state to agent-visible format.</p> <p>Usage in DEgym: Called at the end of <code>step()</code> and <code>reset()</code> to provide agent observations.</p>"},{"location":"terminology/#rewardextractor","title":"RewardExtractor","text":"<p>Computes reward signals based on state transitions (state, action, next_state).</p> <p>Purpose: Implements the optimization objective for the RL agent.</p> <p>Usage in DEgym: Called during <code>step()</code> to provide learning signals to the agent.</p>"},{"location":"terminology/#terminatedextractor","title":"TerminatedExtractor","text":"<p>Determines if an episode should terminate due to natural ending conditions of the MDP.</p> <p>Examples: Achieving objectives, reaching unsafe conditions, violating constraints.</p> <p>Usage in DEgym: Called during <code>step()</code> to check for episode termination.</p>"},{"location":"terminology/#truncatedextractor","title":"TruncatedExtractor","text":"<p>Determines if an episode should truncate due to artificial stopping conditions.</p> <p>Examples: Time limits, maximum timesteps, computational constraints.</p> <p>Usage in DEgym: Called during <code>step()</code> to check for episode truncation.</p>"},{"location":"terminology/#infoextractor","title":"InfoExtractor","text":"<p>Extracts additional diagnostic information useful for monitoring and analysis.</p> <p>Purpose: Provides information for debugging, logging, and analysis but not used by the agent for learning.</p> <p>Usage in DEgym: Called during <code>step()</code> and <code>reset()</code> to provide diagnostic data.</p>"},{"location":"terminology/#integration-components","title":"Integration Components","text":""},{"location":"terminology/#integrator","title":"Integrator","text":"<p>Numerical solver that advances the DAE system over time. Handles the core mathematical simulation of reactor dynamics.</p> <p>Types: - <code>ScipyIntegrator</code>: Uses scipy's ODE solvers. - <code>DiffeqpyIntegrator</code>: Uses DifferentialEquations.jl through Python interface.</p> <p>Usage in DEgym: Called during <code>step()</code> to compute the next state given current state, parameters, and actions.</p>"},{"location":"terminology/#systemdynamicsfn","title":"SystemDynamicsFn","text":"<p>Implements the differential equations that describe the reactor dynamics.</p> <p>Purpose: Defines the mathematical model f in: d/dt dae_state = f(dae_state, dae_params, dae_action).</p> <p>Usage in DEgym: Used by the Integrator to evaluate derivatives during numerical solving.</p>"},{"location":"terminology/#integratorconfig","title":"IntegratorConfig","text":"<p>Configuration parameters for the numerical integrator.</p> <p>Examples: Time step size, solver method, tolerance settings, maximum iterations.</p> <p>Usage in DEgym: Defines how the numerical integration should be performed.</p>"},{"location":"terminology/#environment-components","title":"Environment Components","text":""},{"location":"terminology/#physicalparametersgenerator","title":"PhysicalParametersGenerator","text":"<p>Generates PhysicalParameters for each episode, enabling domain randomization.</p> <p>Usage in DEgym: Called during environment initialization and reset to create diverse training scenarios.</p>"},{"location":"terminology/#initialstategenerator","title":"InitialStateGenerator","text":"<p>Creates initial State instances at the start of episodes using PhysicalParameters.</p> <p>Process: 1. Takes PhysicalParameters as input. 2. Creates initial DAEState (concentrations, temperature, etc.). 3. Generates DAEParameters for equations. 4. Sets up NonDAEParameters for simulation control. 5. Combines into complete State.</p> <p>Usage in DEgym: Called during <code>reset()</code> to establish starting conditions for new episodes.</p>"},{"location":"terminology/#observation","title":"Observation","text":"<p>Data structure that represents what the RL agent can perceive from the environment.</p> <p>Purpose: Encapsulates agent-visible information with conversion to numpy arrays.</p> <p>Usage in DEgym: Created by ObservationExtractor and returned to agents through <code>step()</code> and <code>reset()</code>.</p>"},{"location":"terminology/#key-relationships","title":"Key Relationships","text":"<ol> <li> <p>Raw Action \u2192 Action \u2192 DAEAction: Action processing pipeline that transforms agent outputs to physical control parameters.</p> </li> <li> <p>PhysicalParameters \u2192 State: Configuration-to-simulation mapping that establishes episode parameters.</p> </li> <li> <p>State \u2192 Integrator \u2192 Next State: Core simulation loop that advances system dynamics.</p> </li> <li> <p>State \u2192 Extractors \u2192 RL Outputs: Information extraction that converts internal state to agent-facing data.</p> </li> <li> <p>Environment: Orchestrates all components and provides the standard RL interface.</p> </li> </ol> <p>This terminology forms the foundation for understanding how DEgym separates RL-specific logic (data flow, interfaces) from use-case-specific logic (what actions mean, how states are defined).</p>"}]}