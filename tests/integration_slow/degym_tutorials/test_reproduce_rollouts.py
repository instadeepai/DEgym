# Copyright 2025 InstaDeep Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
File containing test functions to check that the environment can reliably
reproduce rollouts generated by the script `generate_test_rollouts.py`.

These tests are marked with `slow` markers, such that they are not run by default,
but will be run via pytest with the additional CLI argument `-m slow`, e.g.
    > uv run pytest -m slow
"""

import pytest
import os
import pickle
import numpy as np
from pathlib import Path

from omegaconf import OmegaConf
import matplotlib.pyplot as plt

from tests.utils import compare_dicts_with_tolerance
from tests import skip_if_not_diffeqpy
from generate_test_rollouts import get_transition_dict

from degym_tutorials.cstr_tutorial.make_env import make_cstr_environment

CONFIG_PATH = Path(__file__).parent.resolve() / "configs"
DATA_PATH = Path(__file__).parent.resolve() / "data"
PLOTS_PATH = Path(__file__).parent.resolve() / "tmp" / "plots"


def plot_rollouts_comparison(
    true_transitions: list[dict], sampled_transitions: list[dict]
) -> plt.Figure:
    """
    Generate plots for each state dimension, comparing the example (true)
    rollout with the rollout steps sampled during this test run.
    May be useful for debugging in the case that the tests fail.

    Args:
        true_transitions: List of data dictionaries containing true rollout steps.
        sampled_transitions: List of data dictionaries containing sampled rollout steps in this run.
    Returns:
        Comparison plots, showing the evolution of each state dimension over the episode.
    """
    # Retrieve series of states for both true and sampled rollouts
    true_states = [step["dae_state"] for step in true_transitions]
    sampled_states = [step["dae_state"] for step in sampled_transitions]

    # Stack true and sampled states to make [num_timesteps, state_dim] arrays
    true_stacked = np.stack(true_states, axis=0)[:, :-1]  # Exclude timestep
    sampled_stacked = np.stack(sampled_states, axis=0)
    state_dim = true_stacked.shape[-1]

    # Create and plot in subplots for each value dimension
    fig, axs = plt.subplots(1, state_dim, figsize=(8 * state_dim, 6))
    for i in range(state_dim):
        axs[i].plot(true_stacked[:, i], alpha=0.6, label="true")
        axs[i].plot(sampled_stacked[:, i], alpha=0.6, label="sampled")
        axs[i].grid()
        axs[i].legend(loc="best")
        axs[i].set_title(f"state_dim = {i}")
    return fig


def _test_reproduce_rollouts(
    config: OmegaConf, true_transitions: list[dict], plots_name: str
) -> None:
    """
    Test that environment reproduces behaviour over a full episode of interaction.

    Use the same random seed to sample an initial state, then follow a fixed sequence of actions.
    """
    if OmegaConf.select(config, "env_config.random_seed", default=None) is None:
        raise ValueError(
            "env_config.random_seed must be specified in YAML file to ensure reproducibility."
        )
    environment = make_cstr_environment(config.env_config)

    # Reset environment; store initial outputs
    observation_array, info = environment.reset()
    dae_state_array = environment.state.dae_state.to_np_array()
    sampled_transitions = [get_transition_dict(dae_state_array, observation_array, info=info)]

    # Iterate over true_transitions and apply true actions; store data dictionaries
    for true_transition_dict in true_transitions[1:]:
        action = true_transition_dict["action"]
        observation_array, reward, terminated, truncated, info = environment.step(action)
        dae_state_array = environment.state.dae_state.to_np_array()

        sampled_transition_dict = get_transition_dict(
            dae_state_array,
            observation_array,
            info=info,
            action=action,
            reward=reward,
            terminated=terminated,
            truncated=truncated,
        )
        sampled_transitions.append(sampled_transition_dict)

    # Plot and save state rollouts of true and sampled episodes
    fig = plot_rollouts_comparison(true_transitions, sampled_transitions)
    fig.suptitle(f"{plots_name}: test_reproduce_rollout")

    os.makedirs(PLOTS_PATH, exist_ok=True)
    fig.savefig(PLOTS_PATH / f"{plots_name}.png")

    # Loop through data dictionaries and assert equal
    for true_transition, sampled_transition in zip(true_transitions, sampled_transitions):
        assert compare_dicts_with_tolerance(true_transition, sampled_transition), (
            "True and sampled transitions do not match. "
            f"See plot at {PLOTS_PATH / f'{plots_name}.png'} for comparison."
        )


@pytest.mark.slow
@pytest.mark.parametrize("config_name", ["cstr_tutorial"])
def test_reproduce_rollouts_scipy(config_name: str) -> None:
    """
    Test that environment reproduces behaviour over a full episode of interaction.

    Use the same random seed to sample an initial state, then follow a fixed sequence of actions.
    """
    # Load in rollout generated by generate_test_rollouts script
    true_transitions = pickle.load(open(DATA_PATH / config_name / "random_rollout_scipy.pkl", "rb"))
    # Load Hydra config file and instantiate environment
    config = OmegaConf.load(CONFIG_PATH / f"{config_name}.yaml")
    config.env_config.integrator = "scipy"

    _test_reproduce_rollouts(config, true_transitions, f"{config_name}_scipy")


@skip_if_not_diffeqpy
@pytest.mark.slow
@pytest.mark.parametrize("config_name", ["cstr_tutorial"])
def test_reproduce_rollouts_diffeqpy(config_name: str) -> None:
    """
    Test that environment reproduces behaviour over a full episode of interaction.

    Use the same random seed to sample an initial state, then follow a fixed sequence of actions.
    """
    # Load in rollout generated by generate_test_rollouts script
    true_transitions = pickle.load(open(DATA_PATH / config_name / "random_rollout_diffeqpy.pkl", "rb"))
    # Load Hydra config file and instantiate environment
    config = OmegaConf.load(CONFIG_PATH / f"{config_name}.yaml")
    config.env_config.integrator = "diffeqpy"

    _test_reproduce_rollouts(config, true_transitions, f"{config_name}_diffeqpy")
